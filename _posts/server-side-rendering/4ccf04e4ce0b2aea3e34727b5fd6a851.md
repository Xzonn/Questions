---
title: 服务端渲染（SSR）与客户端渲染（CSR）的核心差异
category: 服务端渲染
date: 2025-07-07 00:59
---
服务端渲染（SSR）和客户端渲染（CSR）在渲染机制、性能表现和应用场景上有本质的不同，以下是核心差异的详细概述。

1.  **渲染发生地不同**  
    - SSR 在服务器端预先生成完整的 HTML 页面结构，并将这个包含所有数据的静态 HTML 直接发送给浏览器，用户无需额外等待 JavaScript 的执行即可看到内容。这意味着初始请求返回的就是完整渲染的页面片段，浏览器只需解析和显示这些 HTML/CSS。  
    - CSR 则在服务器端只提供一个几乎为空的内容容器（如 `<div id="root"></div>`），以及相关联的 JavaScript 脚本文件。在客户端运行时，JavaScript 通过异步请求（如 AJAX）获取动态数据，再进行页面内容生成与 DOM 元素拼接。用户在下载和执行 JavaScript 完毕后才能看到完整的页面内容。

2.  **页面内容在初始化请求中的呈现**  
    - 基于前点的机制差异，用户对首屏内容有直接感官：  
      - SSR: 直接显示一个内容完整的可视初始页面，缩短 First Contentful Paint (首屏渲染时间)。  
      - CSR: 由于服务器响应中只含页面骨架元素和逻辑文件，用户通常首先看到空白/加载图标和背景元素，然后等待 JS 运行完后才填充内容[参考摘要]。

3.  **对 SEO 优化的友好性差异显著**  
    - SSR 提供渲染结束后的静态内容，这确保搜索引擎如爬虫技术可以直接抓取全部 HTML 文段内容进行内容分析和排位。这一方式能够有效避免爬虫在 CSR 上遭遇“内容缺失无法索引”的问题[参考摘要]。  
    - CSR 依赖 JavaScript 来填入目标内容，而搜索爬虫大多数是优先理解静态文本，无法运行动态 JS 而直接读到内容不全的数据，从而造成 SEO 排名负面影响[参考摘要][参考摘要]。

4.  **性能负载与网络传输方式不同**  
    - 性能焦点体现在延迟指标：  
      - SSR 首次请求能够生成并一次性传输全部内容到一个包文件来减少 HTTP 请求数目，这通常比 CSR需请求初始页面包（通常是 html/js/css）、脚本文件、可能涉及的后端数据 API 再渲染最终数据等步骤要高效[参考摘要]。  
      - CSR 页面启动需要更多回合式请求：首图→ JS框架下载执行 → API数据抓取，形成多次网络往返延迟问题[参考摘要]。

5.  **适合应用的场景与其开发成本差异对应**  
    - SSR 在注重 SEO 的网站具有显著益处，但也存在局限：包括系统架构代价增加因为需要一个有能力处理前端视图的后端服务如 `Node.js`, 而前端项目也需引入特定适配方法进行“活化”处理（如 `hydration 水合约`）使页面具备逻辑性[参考摘要摘要]。这类结构特别适合如新闻博客或静态页面主导型应用的制作领域[参考参考摘要参考6]。  
    - CSR 以富用户交互和动态行为为重但忽略初始渲染时间和部分引擎爬虫处理受限，其适合低互动平台和原生 WebAppSPA等方案[参考摘要5]。

使用示例代码简要说明差异关键部分：
```html
<!-- SSR 方案处理过的内容块代码：在服务器上已插好最终值的完整响应视图 -->
<template>
  <div class="news">
    <h1>{{ pageTitle }}</h1>
    <p>{{ contentData }}</p> <!-- Content was injected pre-client-side -->
  </div>
</template>

<!-- CSR 方案主要视图块示例（页面基础部分只指定框架容器） -->
<div id="application-root"></div>
<script>
  fetchData("/api/page-data").then(data = > {
    document.getElementById("application-root").innerHTML = renderContent(data);
  }); // Client-rendering after API returns
</script>
```
